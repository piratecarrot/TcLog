<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="TcLogCore" Id="{d1b38a4b-e969-499e-8c20-95d2f11cc391}" SpecialFunc="None">
    <Declaration><![CDATA[/// `TcLogCore` provides the base functionality of the logger and sets the configuration.
/// The logger can be configured by calling its methods that set the configuration.
///
/// > [!NOTE]
/// > `TcLogCore.RunLogger()` should be called once each cycle. The configuration methods should be called **before** 
/// > `RunLogger` is called.
///
/// When declaring an instance of TcLogCore, the ininital buffer size has to be set. If the buffer size is set too low, it will expand
/// automatically if enough memory is available.
///
/// To set the inital buffer size to accomodate 100 messages, use it like this:
///
/// ```st
/// VAR
///   myLogger: TcLogCore(BufferSize := 100 * (Tc2_System.MAX_STRING_LENGTH * Constants.FifoOverhead));
/// END_VAR
/// ```
///
{attribute 'linkalways'}
{attribute 'hide_all_locals'}
FUNCTION_BLOCK PUBLIC TcLogCore IMPLEMENTS ILogCore
VAR
	_loggingSingleton : TcLog; // Logger-Singleton: Required to provide Singleton-functionality for TcLog.
	_utcTimeAsFileTime : Tc2_Utilities.T_FILETIME; // Current utc time as filetime
	_localTimeAsSystemTime : Tc2_Utilities.TIMESTRUCT; // Current local time as timestring
	_localTimeAsString : STRING; // Current local time as string
	_logCache : DynamicStringBuffer; // Dynamic string buffer to cache logs to be processed
	_startLoggingConfiguration : BOOL; // Aux variable to provide fluent interface.
	_internalErrorOccured : BOOL; // Aux variable to log internal errors to Error-property.                                                   				
	_config : LoggingConfiguration; // Logging configuration. Is set by invoking configuration methods.
	_error : Error; // Contains information about internal error.
	_busy : BOOL; // Logger is busy, typically with writing logs to the file system.
  _timeInfoReady : BOOL := FALSE; // Set to true once the time information is available
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Nothing to be done here. Logger works by invoking its methods.
// "RunLogger" contains all the implementation that has to be processed cyclically.]]></ST>
    </Implementation>
    <Method Name="BuildLoggingConfiguration" Id="{20874a43-e751-4fc7-b32e-1b26e60ec927}">
      <Declaration><![CDATA[// Builds logging configuration.
// Required to provide a fluent interface.
// Has to be called at the begin of each method that configures the logger.
{attribute 'hide'}
METHOD PRIVATE BuildLoggingConfiguration : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _startLoggingConfiguration THEN
	_startLoggingConfiguration := TRUE;
	
	_config.RollingInterval := RollingIntervals.Daily;
	_config.WriteToAds := FALSE;
	_config.FileName := '';
	_config.FilePath := 'c:\';
	_config.MinimumLevel := LogLevels.Debug;
	_config.Delimiter := '|';
	_config.IncludeInstancePath := FALSE;
	_config.LogFileLifespan := 0;
	_config.TimestampFormat := 'YYYYMMDD_hhmm_';
	_config.ValidTimestampsOnly := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="Busy" Id="{b4ea3839-cb47-4f13-95fc-c4f72ed1ab1c}">
      <Declaration><![CDATA[/// `Busy` evaluates to `TRUE` as long as the log file is kept open to append new log messages
/// or there are pending messages in the queue to be written to the logfile.
{attribute 'monitoring':='call'}
PROPERTY Busy : BOOL
]]></Declaration>
      <Get Name="Get" Id="{196a9a34-33d9-4154-837f-91768bc70efc}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Busy := _busy;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{198e1a08-5578-4071-919c-cf54ca3cb46d}">
        <Declaration><![CDATA[PRIVATE 
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_busy := Busy;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Configuration" Id="{e3d8da8e-a380-4446-8b1d-7995a970de44}">
      <Declaration><![CDATA[/// Returns the current configuration of the logger.
{attribute 'monitoring':='variable'}
PROPERTY Configuration : LoggingConfiguration
]]></Declaration>
      <Get Name="Get" Id="{01a1c7d9-2988-48df-86c8-15f5ed9657f3}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Configuration := _config;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="DeleteLogFilesAfterDays" Id="{32410822-67bd-4c13-a83d-53eb1112e24c}">
      <Declaration><![CDATA[/// Configuration method which sets the lifespan of log files. Once exceeded, they will be deleted.
METHOD DeleteLogFilesAfterDays : REFERENCE TO TcLogCore
VAR_INPUT
  /// Lifespan of logfiles in days.
	lifespan : UINT; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.LogFileLifespan := lifespan;

DeleteLogFilesAfterDays REF= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Error" Id="{5610f441-4b26-4a11-9b83-8d14b944d1d6}">
      <Declaration><![CDATA[/// Returns information about internal errors.
{attribute 'monitoring':='call'}
{attribute 'suppress_wrn_C0410'}
PROPERTY Error : REFERENCE TO Error
]]></Declaration>
      <Get Name="Get" Id="{fac27f62-5420-4b16-a8c9-901ef364d0d3}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Error REF= _error;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{7fb1634c-c92f-4ed1-a7a5-adc0044327bb}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL; // if TRUE, the instance afterwards gets moved into the copy code (online change)
  /// Initial buffer size for the internal log message buffer
	bufferSize : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_loggingSingleton.Init(THIS^);
_logCache.Init(bufferSize);]]></ST>
      </Implementation>
    </Method>
    <Method Name="FlushCache" Id="{33f9e535-068c-481a-b711-1106ce83d7ac}">
      <Declaration><![CDATA[/// Flushes the logging cache. All messages that have not yet been processed will be lost.
METHOD FlushCache : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_logCache.FlushCache();]]></ST>
      </Implementation>
    </Method>
    <Method Name="IncludeInstancePath" Id="{37657fa7-54f8-40b1-8128-13f2ab0758fd}">
      <Declaration><![CDATA[/// Configuration method. If this method is called, the instance path where the log 
/// messages has been triggered will be included in the log message. 
METHOD IncludeInstancePath : REFERENCE TO TcLogCore
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.IncludeInstancePath := TRUE;

IncludeInstancePath REF= This^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogCustomFormat" Id="{c4c4d490-9bb2-47be-9793-bdb818657719}">
      <Declaration><![CDATA[/// Logger method. It should only be called from within objects that implement `ILog`.
/// Logs data in custom format. No additional formatting will be done. 
METHOD LogCustomFormat : BOOL
VAR_INPUT
  /// Data to be logged.
	data : Tc2_System.T_MaxString; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF(TimeInfoReady OR NOT _config.ValidTimestampsOnly) THEN 
	IF _config.WriteToAds THEN 
		Tc2_System.ADSLOGSTR(ADSLOG_MSGTYPE_LOG OR ADSLOG_MSGTYPE_HINT, data, ''); 
	END_IF
	
	IF _config.FileName <> '' THEN 
		_logCache.AddLine(data);
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogStandardFormat" Id="{5eb90db7-239e-468a-be19-66d260fc9cfa}">
      <Declaration><![CDATA[/// Logger method. It should only be called from within objects that implement `ILog`.
/// Logs in the standard format. This includes
/// - timestamp
/// - log level
/// - log message
/// - instance path of logging source (optional)
/// The message will only be logged if the logging level exceeds the configured minimum logging level.
METHOD LogStandardFormat : BOOL
VAR_INPUT
  /// Data to be logged.
	data : Tc2_System.T_MaxString; 
  /// Instance path of calling logger to locate source of logging message.
	instancePath : Tc2_System.T_MaxString;
  /// Log level of message. 
	logLevel : LogLevels; 
END_VAR
VAR_INST
  {attribute 'hide'}
	messageBuilder : StringBuilder;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF LogLevel >= _config.MinimumLevel AND (TimeInfoReady OR NOT _config.ValidTimestampsOnly)  THEN
	IF _config.WriteToAds THEN 
		Tc2_System.ADSLOGSTR(
			ADSLOG_MSGTYPE_LOG OR LogLevelToAdsLogMsgType(logLevel), 
			messageBuilder
				.Reset()
				.AppendIf(_config.IncludeInstancePath, instancePath)
				.AppendIf(_config.IncludeInstancePath, _config.Delimiter)
				.Append(data)
				.ToString(), 
			''
		); 
	END_IF
	
	IF _config.FileName <> '' THEN 
		_logCache.AddLine(
			messageBuilder
					.Reset()
					.Append(_localTimeAsString)
					.Append(_config.Delimiter)
					.Append(TO_STRING(LogLevel))
					.AppendIf(_config.IncludeInstancePath, _config.Delimiter)
					.AppendIf(_config.IncludeInstancePath, instancePath)
					.Append(_config.Delimiter)
					.Append(data)
					.ToString()
		);
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MinimumLevel" Id="{184800a6-c363-4941-96c0-25802b6c2195}">
      <Declaration><![CDATA[/// Configuration method.
/// Sets the minimum log level. Log messages below this level 
/// will not be logged.
METHOD MinimumLevel : REFERENCE TO TcLogCore
VAR_INPUT
  /// Minimum log level to be logged.
	level : LogLevels; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.MinimumLevel := level;

MinimumLevel REF=THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RollingIntervalReached" Id="{2bbbfddc-c76b-4011-9b1b-5d8fb4ee58fc}">
      <Declaration><![CDATA[// Checks the specified rolling interval for the file name.
// Generates new file name if rolling intervall exceeded.
{attribute 'hide_all_locals'}
{attribute 'hide'}
METHOD PRIVATE RollingIntervalReached : BOOL
VAR_INPUT
	currentUtcTime : Tc2_Utilities.TIMESTRUCT;  // Current system time as utc
	rollingInterval : RollingIntervals; // Rolling interval 
END_VAR
VAR_INST
	newHour : Tc2_Standard.R_TRIG;
	newDay : Tc2_Standard.R_TRIG;
	newMonth : Tc2_Standard.R_TRIG;
	
	hourRolled : BOOL;
	dayRolled : BOOL;
	monthRolled : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[newHour(CLK := (currentUtcTime.wMinute = 0 AND currentUtcTime.wSecond = 0), 
	Q => hourRolled);
newDay(CLK := (hourRolled AND currentUtcTime.wHour = 0), 
	Q => dayRolled);
newMonth(CLK := (dayRolled AND currentUtcTime.wDay = 1), 
	Q => monthRolled);

RollingIntervalReached := 	(hourRolled 	AND rollingInterval = RollingIntervals.Hourly) OR
							(dayRolled 		AND rollingInterval = RollingIntervals.Daily) 	OR
							(monthRolled 	AND rollingInterval = RollingIntervals.Monthly);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RunLogger" Id="{803fadf5-6bd4-4200-a13b-16a67d07d8d9}">
      <Declaration><![CDATA[/// Cyclic method of Logger.
/// This method has to be executed in every plc cycle and runs 
/// all internal methods that have to be executed cyclically.
/// > [!NOTE]
/// > This method should be the last method of `TcLogCore` to be called in each cycle.
{attribute 'hide_all_locals'}
METHOD RunLogger : BOOL
VAR_INST
	newDay : Tc2_Standard.R_TRIG; 
	dateTime : DateTime;
	deleteExpiredLogFiles : DeleteOldFiles;
	fileNameStringBuilder : StringBuilder;
	timeStamp : STRING; // Timestamp used for filename
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Generate time data (shared state)
dateTime();
IF dateTime.Done THEN _timeInfoReady := TRUE; END_IF

_localTimeAsSystemTime := dateTime.AsLocalSystemTime;
_localTimeAsString := dateTime.AsLocalSystemTimeString;
_utcTimeAsFileTime := dateTime.AsUtcFileTime;

// Generate new timestamp for filename
IF RollingIntervalReached(_localTimeAsSystemTime, _config.RollingInterval) OR dateTime.Done THEN
	timeStamp := dateTime.ToFormatString(_config.TimestampFormat);
END_IF

// Delete expired log files
newDay(CLK := _localTimeAsSystemTime.wHour = 0);
deleteExpiredLogFiles(
	StartScan 			:= 	newDay.Q AND (_config.LogFileLifespan > 0),
	ExpirationInDays 	:=	_config.LogFileLifespan,
	FilePath			:=	_config.FilePath,
	FileName 			:=	_config.FileName,
	CurrentUtcTime 		:= 	_utcTimeAsFileTime	
	);
IF deleteExpiredLogFiles.Error.Active THEN
	_internalErrorOccured := TRUE;
	_error := deleteExpiredLogFiles.Error;
END_IF
		
// Persist logging messages to file
_logCache.PersistToFile(
  TimeInfoReady,
	fileNameStringBuilder
		.Reset()
		.Append(_config.FilePath)
		.AppendIf(Tc2_Standard.RIGHT(_config.FilePath, 1) <> '\', '\')
		.Append(timeStamp)
		.Append(_config.FileName)
		.ToString()
);
IF _logCache.Error.Active THEN
	_internalErrorOccured := TRUE;
	_error := _logCache.Error;
END_IF

// Forward busy state of LogCache 
Busy := _logCache.Busy;

// Reset Logging configuration: neccesary in order to provide fluent interface
_startLoggingConfiguration := FALSE;

// Reset error flag each cycle to automatically confirm errors once they are gone.
IF NOT _internalErrorOccured THEN
	_error.Active := FALSE;
	_error.Code := ErrorCodes.None;
	_error.Info := '';
END_IF
_internalErrorOccured := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDelimiter" Id="{174c6212-1cd1-4e95-ae71-92ba063e3be0}">
      <Declaration><![CDATA[/// Configuration method
/// Sets delimiter between different columns of log file.
METHOD SetDelimiter : REFERENCE TO TcLogCore
VAR_INPUT
  /// Delimiter between different columns of log file.
	delimiter : STRING(1); 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.Delimiter := delimiter;

SetDelimiter REF=THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetRollingInterval" Id="{6b6a98f5-4ff4-49b0-80a7-0a8439a6af3a}">
      <Declaration><![CDATA[/// Configuration method.
/// Sets the rolling interval of the log file. Once the rolling interval
/// expires, a file name with a new timestamp will be generated.
METHOD SetRollingInterval : REFERENCE TO TcLogCore
VAR_INPUT
  /// Rolling interval for log file. Once exceeded, a new log file will be created.
	interval : RollingIntervals; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.RollingInterval := interval;

SetRollingInterval REF= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Property Name="TimeInfoReady" Id="{54c6c479-5e1d-451f-a86a-69dc83c416dc}">
      <Declaration><![CDATA[/// `TimeInfoReady` evaluates to `TRUE` once the time information used by determine
/// the timestamp for the message is available.
{attribute 'monitoring':='call'}
PROPERTY TimeInfoReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{85e8d87e-b3db-489a-bdce-0fefffb116e4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TimeInfoReady := _timeInfoReady;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="TimestampFormat" Id="{03e96e15-d1a5-4041-b07d-134333275170}">
      <Declaration><![CDATA[/// Configuration method.
/// Sets the format of the timestamp in the file name. 
/// 
/// The following format options are available:
///	Y : year
///	M : month
/// D : day
/// h : hour 
/// m : minute
/// s : second
/// i : millisecond
/// 
/// Example: _YYMMDD-hh:mm:ss:iii_
/// => _20210812-12:30:22:123_
METHOD TimestampFormat : REFERENCE TO TcLogCore
VAR_INPUT
  /// Format the timestamp should have.
	format : STRING; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.TimestampFormat := format;

TimestampFormat REF= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ValidTimestampsOnly" Id="{153f65bb-4e2c-4c4e-873b-44caa283f25b}">
      <Declaration><![CDATA[/// Configuration method. If this method is called, only valid timestamps are logged.
/// Note that using this configuration will skip logging anything during the first few PLC cycles, 
/// as TwinCAT needs a few cycles to initialize its time information.
METHOD ValidTimestampsOnly : REFERENCE TO TcLogCore
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.ValidTimestampsOnly := TRUE;

ValidTimestampsOnly REF= This^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteToAds" Id="{790074cc-53f8-4c6d-bb4d-92d315fc1666}">
      <Declaration><![CDATA[/// Configuration method.
/// If this method is called, the logs will be written to ADS.
METHOD WriteToAds : REFERENCE TO TcLogCore
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

_config.WriteToAds := TRUE;

WriteToAds REF= This^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteToFile" Id="{8d0ef236-af26-43bb-90b3-e489d1df8093}">
      <Declaration><![CDATA[/// Configuration method.
/// If this method is called, the logs will be persisted to the file system.
METHOD WriteToFile : REFERENCE TO TcLogCore
VAR_INPUT
  /// File path the logs will be written to.
	path : Tc2_System.T_MaxString; 
  /// File name of the log file. Will automatically be prefixed by timestamp.
	fileName : STRING; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[BuildLoggingConfiguration();

IF Tc2_Standard.RIGHT(path, 1) <> '\' THEN
  _config.FilePath := TC2_Standard.CONCAT(path, '\');  
ELSE
  _config.FilePath := path;
END_IF
_config.FileName := fileName;

WriteToFile REF= This^;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>