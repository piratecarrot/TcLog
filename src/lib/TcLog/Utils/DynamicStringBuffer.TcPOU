<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="DynamicStringBuffer" Id="{2126ae4b-ae71-49f5-b368-31058f9bbaa3}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_explicit_call' := 'This FB is a CLASS and must be accessed using methods or properties'}
{attribute 'hide_all_locals'}
FUNCTION_BLOCK INTERNAL DynamicStringBuffer
VAR_OUTPUT
	Error : Error; // Error information of this FB
END_VAR
VAR
	_fifo : Tc2_Utilities.FB_StringRingBuffer; // Necessary to buffer log data until it has been written to file.
	_memoryManager : Tc3_DynamicMemory.FB_DynMem_Manager; // Memory manager, required by DynMem_Buffer.
	_dynamicMemoryBuffer : Tc3_DynamicMemory.FB_DynMem_Buffer(ipMemMan := _memoryManager); // Provides dynamic buffer for Fifo. Is extended automatically if more than the
																   // default buffer size is needed.                  
	_busy : BOOL; // Buffer is busy; typically with writing data to the file system.
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddLine" Id="{dba2eed5-180a-41e2-b547-daf2b63c34e8}">
      <Declaration><![CDATA[METHOD AddLine : BOOL
VAR_INPUT
  text : Tc2_System.T_MaxString; // Text to be added to the buffer
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResizeFifoBufferIfNecessary();
_fifo.A_AddTail(putValue := Tc2_Standard.CONCAT(Tc2_Standard.LEFT(text, 254), '$N')); ]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddString" Id="{57490981-4745-43fe-8970-8374327032f7}">
      <Declaration><![CDATA[METHOD AddString : BOOL
VAR_INPUT
  text : Tc2_System.T_MaxString; // String to be added to the buffer
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResizeFifoBufferIfNecessary();
_fifo.A_AddTail(putValue := text); ]]></ST>
      </Implementation>
    </Method>
    <Method Name="AllocateBuffer" Id="{1e1ae43d-3f2a-4e64-9d1a-2ad6b0778bac}">
      <Declaration><![CDATA[METHOD PRIVATE AllocateBuffer : BOOL // Allocates buffer FOR the fifo.
VAR_INPUT
  bufferSize : UDINT; // Initial buffer size in BYTEs for fifo buffer.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_dynamicMemoryBuffer.CreateBuffer(nSize:=bufferSize, bReset:=TRUE);
_fifo.pBuffer := _dynamicMemoryBuffer.pBuffer;
_fifo.cbBuffer := bufferSize;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Busy" Id="{cf6eff50-747b-4183-9859-df0235949db5}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Busy : BOOL
]]></Declaration>
      <Get Name="Get" Id="{af124c85-87a2-43f9-9885-3df2fd395467}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Busy := _busy;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{8cd9ec74-b1c4-4b38-8b4d-97faad8c19b6}">
        <Declaration><![CDATA[PRIVATE
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_busy := Busy;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="FB_exit" Id="{9f719fef-e506-4643-8113-ed7ed04ca644}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
  bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_dynamicMemoryBuffer.Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FlushCache" Id="{a5756f46-f3f9-49a6-8459-ac574fef5361}">
      <Declaration><![CDATA[METHOD FlushCache : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_fifo.A_Reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{83f9437f-5c9e-4e72-9a3b-0085311ce9bd}">
      <Declaration><![CDATA[METHOD INTERNAL Init : BOOL
VAR_INPUT
	bufferSize : UDINT; // Initial buffer size in BYTEs for fifo buffer.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AllocateBuffer(bufferSize);]]></ST>
      </Implementation>
    </Method>
    <Method Name="PersistToFile" Id="{6db57e8f-da81-4608-a737-9d282480265b}">
      <Declaration><![CDATA[{attribute 'hide_all_locals'}
METHOD PersistToFile : BOOL
VAR_INPUT
  enable: BOOL; // TRUE starts persistence mechanism
  fileName : Tc2_System.T_MaxString; // File name including its path
END_VAR
VAR_INST
  state : PersistToFileState;
  
  fileOpen : Tc2_System.FB_FileOpen;
  fileHandle : UINT;
  
  fileWrite : Tc2_System.FB_FileWrite;
  lockFileWriteToForceRisingEdge : BOOL; // filePuts can only be executed every other cycle
                                         // since it needs a rising edge to execute.
  fileClose : Tc2_System.FB_FileClose;
  
  buffer : ARRAY[0..CONSTANTS.BufferSize] OF BYTE;
  currentBufferPos : UDINT;
  fifoHeadString : Tc2_System.T_MaxString;
  fifoHeadLength : UDINT;
  fifoHeadBytes : ARRAY[0..Tc2_System.MAX_STRING_LENGTH] OF BYTE;
  i : UINT;
END_VAR
VAR CONSTANT
  NetId : STRING := '';
  Timeout : TIME := DEFAULT_ADS_TIMEOUT;
  MaxLogsPerCycle : UINT := UDINT_TO_UINT(CONSTANTS.BufferSize / Tc2_System.MAX_STRING_LENGTH);
  MaxBufferPosition : UDINT := (SIZEOF(buffer)-Tc2_System.MAX_STRING_LENGTH);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// State machine
// Using if-statements instead of case for performance reasons:
// Some states execute instantly and allow thus the next state 
// to start within the same plc cycle.

// *** I D L E ***
IF state = PersistToFileState.Idle THEN
  lockFileWriteToForceRisingEdge := FALSE;
  IF _fifo.nCount > 0 AND enable THEN 
    lockFileWriteToForceRisingEdge := FALSE;
    state := PersistToFileState.OpenFile;
  END_IF
END_IF
    
// *** O P E N   F I L E ***
fileOpen(sNetId := NetId, sPathName := fileName, nMode := FOPEN_MODEAPPEND OR FOPEN_MODETEXT, 
           ePath := PATH_GENERIC, bExecute := (state = PersistToFileState.OpenFile), tTimeout := Timeout,
           hFile => fileHandle);

IF state = PersistToFileState.OpenFile THEN
  IF fileOpen.bError THEN
    state := PersistToFileState.CloseFile;
  ELSIF NOT fileOpen.bBusy THEN
    state := PersistToFileState.GetStringFromFifo; 
  END_IF
END_IF 

// *** P O P   F R O M   F I F O ***
IF state = PersistToFileState.GetStringFromFifo THEN
  IF NOT lockFileWriteToForceRisingEdge THEN
    currentBufferPos := 0;
    FOR i:=0 TO MaxLogsPerCycle DO
      IF _fifo.nCount <= 0 THEN EXIT; END_IF
      IF currentBufferPos >= MaxBufferPosition THEN EXIT; END_IF
      
      _fifo.A_RemoveHead(getValue => fifoHeadString); 
      fifoHeadBytes := MAXSTRING_TO_BYTEARR(fifoHeadString);
      fifoHeadLength := INT_TO_UDINT(LEN(fifoHeadString));
      MEMCPY(
        destAddr  :=  ADR(buffer) + SIZEOF(BYTE) * currentBufferPos,
        srcAddr   :=  ADR(fifoHeadBytes),
        n     :=  fifoHeadLength);    
      currentBufferPos := currentBufferPos + fifoHeadLength;  
    END_FOR
    state := PersistToFileState.AppendDataToFile;
  END_IF
  lockFileWriteToForceRisingEdge := FALSE;
END_IF
  
// *** W R I T E   T O   F I L E ***
fileWrite(
  sNetId := NetId, 
  hFile := fileHandle, 
  pWriteBuff := ADR(buffer),
  cbWriteLen := currentBufferPos,
  bExecute := state = PersistToFileState.AppendDataToFile, 
  tTimeout := Timeout); 

IF state = PersistToFileState.AppendDataToFile THEN
  lockFileWriteToForceRisingEdge := TRUE;   
  IF fileWrite.bError THEN
    state := PersistToFileState.CloseFile;
  ELSIF _fifo.nCount > 0 AND NOT fileWrite.bBusy THEN
    state := PersistToFileState.GetStringFromFifo; 
  ELSIF _fifo.nCount = 0 THEN
    state := PersistToFileState.CloseFile;
  END_IF
END_IF
    
// *** C L O S E   F I L E ***
fileClose(
  sNetId := NetId, hFile := fileHandle, 
  bExecute := (state = PersistToFileState.CloseFile), tTimeout := Timeout);

IF state = PersistToFileState.CloseFile THEN
  IF NOT fileClose.bBusy THEN state := PersistToFileState.Idle; END_IF
END_IF

// Close file in case of error
IF fileOpen.bError THEN state := PersistToFileState.CloseFile; END_IF
IF fileWrite.bError THEN state := PersistToFileState.CloseFile; END_IF
IF NOT _fifo.bOk AND _fifo.nCount > 0 AND state <> PersistToFileState.Idle THEN 
  state := PersistToFileState.CloseFile; 
END_IF

// Error handling
IF fileOpen.bError THEN
  Error.Active := TRUE;
  Error.Code := ErrorCodes.OpeningFileFailed;
  Error.Info := Tc2_Standard.CONCAT('Opening file failed. Error thrown by FB_FileOpen. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fileOpen.nErrId));
ELSIF fileWrite.bError THEN
  Error.Active := TRUE;
  Error.Code := ErrorCodes.WritingToFileFailed;
  Error.Info := Tc2_Standard.CONCAT('Writing to file failed. Error thrown by FB_FileWrite. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fileWrite.nErrId));
ELSIF fileClose.bError THEN
  Error.Active := TRUE;
  Error.Code := ErrorCodes.ClosingFileFailed;
  Error.Info := Tc2_Standard.CONCAT('Closing file failed. Error thrown by FB_FileClose. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fileClose.nErrId));
ELSIF NOT _fifo.bOk AND _fifo.nCount > 0 THEN
  Error.Active := TRUE;
  Error.Code := ErrorCodes.FifoOverflow;
  Error.Info := 'FIFO overflow. Check if plc has enough free memory.';
ELSE
  Error.Active := FALSE;
  Error.Code := ErrorCodes.None;
  Error.Info := '';
END_IF

// Set busy state
Busy := (state <> PersistToFileState.Idle OR _fifo.nCount > 0);

(* Uncomment for cyclic logging of state machine, buffer usage & errors

ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
  Tc2_Standard.CONCAT('****DynamicStringBuffer.state:', 
  Tc2_Standard.CONCAT(UINT_TO_STRING(state),
  Tc2_Standard.CONCAT(', DynamicStringBuffer.hFile:', UINT_TO_STRING(hFile)))), '');

ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
  Tc2_Standard.CONCAT('****Fifo: used ', 
  Tc2_Standard.CONCAT(UDINT_TO_STRING(Fifo.cbSize),
  Tc2_Standard.CONCAT(' of ', UDINT_TO_STRING(Fifo.cbBuffer)))), '');
  
IF Error.Active THEN
  ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
    Tc2_Standard.CONCAT('****DynamicStringBuffer.Error: ', Error.Info), 
    '');  
END_IF
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="PopHead" Id="{f5c275b6-f52e-44ed-8e72-f85d52a0b83a}">
      <Declaration><![CDATA[METHOD PopHead : Tc2_System.T_MaxString
VAR_INST
  headString : Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_fifo.A_RemoveHead(getValue => headString);
PopHead := headString;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResizeFifoBufferIfNecessary" Id="{864a26f2-0a90-425f-b718-0b65714dd427}">
      <Declaration><![CDATA[// Resizes the buffer for the FIFO if necessary
METHOD PRIVATE ResizeFifoBufferIfNecessary : BOOL
VAR
  requiredSize : UDINT;
  newSize : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[requiredSize := _fifo.cbSize + (Tc2_System.MAX_STRING_LENGTH + Constants.FifoOverhead);

IF requiredSize > _fifo.cbBuffer THEN
  _dynamicMemoryBuffer.Resize(nSize := requiredSize*SIZEOF(BYTE), bPreserve:=TRUE, bReset:=TRUE);
  _fifo.pBuffer := _dynamicMemoryBuffer.pBuffer;
  _fifo.cbBuffer := requiredSize;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>